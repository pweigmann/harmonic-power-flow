# 4 Bus example of "classical" harmonic load power based on Xia/Fuchs
# Starting with example of fundamental load power chapter 7.3, then harmonic
# extension in chapter 7.4 of Fuchs.2008

# Author: Pascal Weigmann, p.weigmann@posteo.de

import numpy as np
import pandas as pd

pu_factor = 1000  # as in PyPSA example


# functions to change from algebraic to polar form
def P2A(radii, angles):
    return radii * np.exp(1j*angles)


def A2P(x):
    return abs(x), np.angle(x)


# initialize voltage as multi-index DataFrame
iterables = [[1, 5], ["bus1", "bus2", "bus3", "bus4"]]
multiIdx = pd.MultiIndex.from_product(iterables, names=['harmonic', 'bus'])
V = pd.DataFrame(np.array([[1, 0], [1, 0], [1, 0], [1, 0],
                           [0.1, 0], [0.1, 0], [0.1, 0], [0.1, 0]]),
                 index=multiIdx, columns=["V_m", "V_p"])
V.sort_index(inplace=True)

# grid: buses and lines with their constant properties
buses = pd.DataFrame(np.array([[1, "slack", 0, 0, 1000],
                               [2, "PQ", 100, 100, None],
                               [3, "PQ", 0, 0, None],
                               [4, "nonlinear", 250, 100, None]]),
                     columns=["ID", "type", "P", "Q", "S"])
lines = pd.DataFrame(np.array([[1, 1, 2, 0.01, 0.01],
                               [2, 2, 3, 0.02, 0.08],
                               [3, 3, 4, 0.01, 0.02],
                               [4, 4, 1, 0.01, 0.02]]),
                     columns=["ID", "fromID", "toID", "R", "X"])

# 7.3.5: construct Y_f
Y_f = np.zeros([lines.shape[0], lines.shape[0]], dtype=complex)
# non-diagonal elements
for k in range(0, lines.shape[0]):
    Y_f[int(lines.fromID[k])-1, int(lines.toID[k])-1] = \
        -1/(lines.R[k] + 1j*lines.X[k])
    Y_f[int(lines.toID[k])-1, int(lines.fromID[k])-1] =\
        Y_f[int(lines.fromID[k])-1, int(lines.toID[k])-1]

# diagonal elements
for n in range(0, lines.shape[0]):
    for m in range(0, lines.shape[0]):
        if n == m:
            # won't work if there are more than two lines per bus
            # simpler to use sum of values calculated above
            Y_f[n, m] = 1/(lines[lines.fromID == n+1].R.iloc[0] +
                           1j*lines[lines.fromID == n+1].X.iloc[0]) +\
                        (1/(lines[lines.toID == n+1].R.iloc[0] +
                            1j*lines[lines.toID == n+1].X.iloc[0]))

Y_f_p = np.zeros([lines.shape[0], lines.shape[0]], dtype=tuple)
for n in range(0, lines.shape[0]):
    for m in range(0, lines.shape[0]):
        Y_f_p[n, m] = A2P(Y_f[n, m])

# --> correct!

# 7.3.6: fundamental mismatch vector (doesn't contain slack bus)
V_pol = V.loc[1, "V_m"]*np.exp(1j*V.loc[1, "V_p"])
V_init = pd.Series([])
for n in range(0, len(V_pol)):
    V_init = V_init.append(pd.Series([V_pol[n].imag, V_pol[n].real],
                                     index=["V_" + str(n) + "_theta",
                                     "V_" + str(n) + "_m"]))
S = buses["P"]/pu_factor+1j*buses["Q"]/pu_factor
dm = np.array(V_pol*np.conj(Y_f.dot(V_pol))) - np.array(S)

# manuel variant as written in fuchs
# F_r = np.zeros(len(buses))
# F_i = np.zeros(len(buses))
#
# for n in range(1, len(buses)):
#     for m in range(0, len(buses)):
#         F_r[n] = F_r[n] + Y_f_p[n, m][0]*V.iloc[n, 0]*V.iloc[m, 0] * \
#                  np.cos(-Y_f_p[n, m][1] - V.iloc[m, 1] + V.iloc[n, 1])
#         F_i[n] = F_i[n] + Y_f_p[n, m][0]*V.iloc[n, 0]*V.iloc[m, 0] * \
#                  np.sin(-Y_f_p[n, m][1] - V.iloc[m, 1] + V.iloc[n, 1])
#
# dm2 = F_r[1:] + 1j*F_i[1:] - S[1:]

# max norm best choice?
err = np.linalg.norm(dm, np.Inf)

# 7.3.7: fundamental Jacobian
dSdt = - V_pol*np.conj(Y_f.dot(V_pol))

