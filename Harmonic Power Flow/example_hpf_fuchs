# 4 Bus example of "classical" harmonic load power based on Xia/Fuchs
# Starting with example of fundamental load power chapter 7.3, then harmonic
# extension in chapter 7.4 of Fuchs.2008.
# Unnecessarily complicated as Fuchs calculates by hand using angles opposed
# to computer based complex calculations in algebraic form. Also uses different
# ordering of variables as pypsa and rounds numbers after 3 decimals.

# Author: Pascal Weigmann, p.weigmann@posteo.de

import numpy as np
import pandas as pd

pu_factor = 1000


# functions to change from algebraic to polar form
def P2A(radii, angles):
    return radii * np.exp(1j*angles)


def A2P(x):
    return abs(x), np.angle(x)


# initialize voltage as multi-index DataFrame
iterables = [[1, 5], ["bus1", "bus2", "bus3", "bus4"]]
multiIdx = pd.MultiIndex.from_product(iterables, names=['harmonic', 'bus'])
V = pd.DataFrame(np.array([[1, 0], [1, 0], [1, 0], [1, 0],
                           [0.1, 0], [0.1, 0], [0.1, 0], [0.1, 0]]),
                 index=multiIdx, columns=["V_m", "V_p"])
V.sort_index(inplace=True)

# grid: buses and lines with their constant properties
buses = pd.DataFrame(np.array([[1, "slack", 0, 0, 1000],
                               [2, "PQ", 100, 100, None],
                               [3, "PQ", 0, 0, None],
                               [4, "nonlinear", 250, 100, None]]),
                     columns=["ID", "type", "P", "Q", "S"])
lines = pd.DataFrame(np.array([[1, 1, 2, 0.01, 0.01],
                               [2, 2, 3, 0.02, 0.08],
                               [3, 3, 4, 0.01, 0.02],
                               [4, 4, 1, 0.01, 0.02]]),
                     columns=["ID", "fromID", "toID", "R", "X"])

# 7.3.5: construct Y_f
Y_f = np.zeros([lines.shape[0], lines.shape[0]], dtype=complex)
# non-diagonal elements
for k in range(0, lines.shape[0]):
    Y_f[int(lines.fromID[k])-1, int(lines.toID[k])-1] = \
        -1/(lines.R[k] + 1j*lines.X[k])
    Y_f[int(lines.toID[k])-1, int(lines.fromID[k])-1] =\
        Y_f[int(lines.fromID[k])-1, int(lines.toID[k])-1]

# diagonal elements
for n in range(0, lines.shape[0]):
    for m in range(0, lines.shape[0]):
        if n == m:
            # won't work if there are more than two lines per bus
            # simpler to use sum of values calculated above
            Y_f[n, m] = 1/(lines[lines.fromID == n+1].R.iloc[0] +
                           1j*lines[lines.fromID == n+1].X.iloc[0]) +\
                        (1/(lines[lines.toID == n+1].R.iloc[0] +
                            1j*lines[lines.toID == n+1].X.iloc[0]))

Y_f_p = np.zeros([lines.shape[0], lines.shape[0]], dtype=tuple)
for n in range(0, lines.shape[0]):
    for m in range(0, lines.shape[0]):
        Y_f_p[n, m] = A2P(Y_f[n, m])

# --> correct!

# 7.3.6: fundamental mismatch vector (doesn't contain slack bus)
V_f = V.loc[1, "V_m"]*np.exp(1j*V.loc[1, "V_p"])
V_init = pd.Series([])
for n in range(0, len(V_f)):
    V_init = V_init.append(pd.Series([V_f[n].imag, V_f[n].real],
                                     index=["V_" + str(n) + "_theta",
                                     "V_" + str(n) + "_m"]))
S = buses["P"]/pu_factor+1j*buses["Q"]/pu_factor
dm = np.array(V_f*np.conj(Y_f.dot(V_f))) + np.array(S)

# Newton Raphson variables (without slack bus)
x = V_init[2:]
f = np.zeros(2*(len(dm)-1))
for n in range(1, len(dm)):
    f[2*n-2] = dm[n].real
    f[2*n-1] = dm[n].imag

err = np.linalg.norm(dm, np.Inf)  # max norm best choice?

# 7.3.7: fundamental Jacobian (calculated the way pypsa does)
I_diag = np.diag(Y_f.dot(V_f))
V_diag = np.diag(V_f)
V_diag_norm = np.diag(V_f/abs(V_f))

dSdt = 1j*V_diag.dot(np.conj(I_diag - Y_f.dot(V_diag)))
dPdt = dSdt.real
dQdt = dSdt.imag

dSdV = V_diag_norm.dot(np.conj(I_diag)) + \
       V_diag.dot(np.conj(Y_f.dot(V_diag_norm)))
dPdV = dSdV.real
dQdV = dSdV.imag

# order of jacobian entries is differs from pypsa to fuchs, sorting:
Jb = np.zeros((2*len(buses), 2*len(buses)))

for n in range(len(buses)):
    for m in range(len(buses)):
        Jb[2*n, 2*m] = dPdt[n, m]
        Jb[2*n+1, 2*m] = dQdt[n, m]
        Jb[2*n, 2*m+1] = dPdV[n, m]
        Jb[2*n+1, 2*m+1] = dQdV[n, m]

J = Jb[2:, 2:]  # correct! (Fuchs, p.591)

# 7.3.8: calculate the inverse of the Jacobian
J_inv = np.linalg.inv(J)

# 7.3.10: compute correction vector + iterate
x_new = x - J_inv.dot(f)
# update voltage:
V.loc[1, 'V_p'][1:] = x_new[::2]
V.loc[1, 'V_m'][1:] = x_new[1::2]

n_iter = 0
# calculate again: f, J  (loop shouldn't start here, but lazy)
while err > 0.0001 and n_iter < 100:
    n_iter += 1
    V.loc[1, 'V_p'][1:] = x_new[::2]
    V.loc[1, 'V_m'][1:] = x_new[1::2]
    V_f = V.loc[1, "V_m"]*np.exp(1j*V.loc[1, "V_p"])
    dm = np.array(V_f*np.conj(Y_f.dot(V_f))) + np.array(S)
    x = x_new  # update x
    for n in range(1, len(dm)):  # update f
        f[2*n-2] = dm[n].real
        f[2*n-1] = dm[n].imag

    err = np.linalg.norm(f, np.Inf)

    # recalculate J
    I_diag = np.diag(Y_f.dot(V_f))
    V_diag = np.diag(V_f)
    V_diag_norm = np.diag(V_f/abs(V_f))
    dSdt = 1j*V_diag.dot(np.conj(I_diag - Y_f.dot(V_diag)))
    dPdt = dSdt.real
    dQdt = dSdt.imag

    dSdV = V_diag_norm.dot(np.conj(I_diag)) + \
           V_diag.dot(np.conj(Y_f.dot(V_diag_norm)))
    dPdV = dSdV.real
    dQdV = dSdV.imag

    for n in range(len(buses)):
        for m in range(len(buses)):
            Jb[2*n, 2*m] = dPdt[n, m]
            Jb[2*n+1, 2*m] = dQdt[n, m]
            Jb[2*n, 2*m+1] = dPdV[n, m]
            Jb[2*n+1, 2*m+1] = dQdV[n, m]

    J = Jb[2:, 2:]
    J_inv = np.linalg.inv(J)
    x_new = x - J_inv.dot(f)
    print("error: " + str(err))
print(x_new)  # voltage magnitudes same as fuchs, angles a bit off, strange
print(str(n_iter) + " iterations")

# HARMONIC POWER FLOW